import os
import torch
from torch.utils.data import DataLoader
from preprocess.dataloader import CrowdGraphDataset, collate_fn
from models.stgnn import STGNN

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

def compute_metrics(pred, target, inp):
    """Compute evaluation metrics"""
    true_xy = target.x[:, :2]
    mse = torch.mean((pred - true_xy) ** 2).item()  # anomaly score
    num_people = true_xy.shape[0]                   # people count
    dxdy = inp.x[:, 2:4]
    avg_movement = torch.mean(torch.sqrt(torch.sum(dxdy ** 2, dim=1))).item()

    return {
        "anomaly_score": mse,
        "num_people": num_people,
        "avg_movement": avg_movement
    }

def main():
    root = "D:/stgnn_project/data/processed/txt_graphs"
    checkpoint = "checkpoints/stgnn_baseline.pth"
    
    # --- Checkpoint validation ---
    if not os.path.exists(checkpoint):
        print(f"[ERROR] Checkpoint not found: {checkpoint}")
        print("[INFO] Please ensure training completed successfully and checkpoint was saved.")
        return
    
    # --- Dataset validation ---
    if not os.path.exists(root):
        print(f"[ERROR] Data root directory not found: {root}")
        return
    
    test_dir = os.path.join(root, "test")
    if not os.path.exists(test_dir):
        print(f"[ERROR] Test directory not found: {test_dir}")
        print("[INFO] Please ensure test data was generated by graph_builder.py")
        return
    
    # Check if test directory has .pt files
    test_files = [f for f in os.listdir(test_dir) if f.endswith(".pt")]
    if len(test_files) == 0:
        print(f"[ERROR] No .pt files found in {test_dir}")
        print("[INFO] Please run graph_builder.py to generate test graphs")
        return
    
    # --- Load dataset ---
    test_dataset = CrowdGraphDataset(root, split="test")
    
    # Check if dataset has any sequences
    if len(test_dataset) == 0:
        print("[ERROR] Test dataset has no sequences!")
        print(f"[INFO] Found {len(test_files)} .pt files, but none could be loaded.")
        return
    
    # Check if any sequences have valid frame pairs
    valid_sequences = 0
    for i in range(len(test_dataset)):
        try:
            samples = test_dataset[i]  # This calls get(i)
            if len(samples) > 0:
                valid_sequences += 1
        except Exception as e:
            print(f"[WARNING] Error loading sequence {i}: {str(e)}")
    
    if valid_sequences == 0:
        print("[ERROR] All test sequences have no valid consecutive frame pairs!")
        print("[INFO] This likely means node counts don't match between consecutive frames.")
        print("[INFO] Consider adjusting max_track_distance in graph_builder.py or using tracking IDs.")
        return
    
    # --- Load model ---
    try:
        model = STGNN(in_channels=5, hidden_channels=32, out_channels=2, num_layers=2).to(device)
        model.load_state_dict(torch.load(checkpoint, map_location=device))
        model.eval()
        print(f"[INFO] Loaded model from {checkpoint}")
    except Exception as e:
        print(f"[ERROR] Failed to load model: {str(e)}")
        print("[INFO] Check that the model architecture matches the saved checkpoint.")
        return
    
    # --- DataLoader ---
    test_loader = DataLoader(test_dataset, batch_size=1, collate_fn=collate_fn, shuffle=False)
    
    # Check if loader will yield any data
    total_pairs = 0
    for seq_samples in test_dataset:
        total_pairs += len(seq_samples)
    
    if total_pairs == 0:
        print("[ERROR] No valid (input,target) pairs found in test dataset!")
        print("[INFO] All consecutive frames have mismatched node counts.")
        return
    
    print(f"[INFO] Test sequences: {len(test_dataset)}")
    print(f"[INFO] Total valid frame pairs: {total_pairs}")
    
    # --- Run inference ---
    processed_sequences = 0
    processed_frames = 0
    
    with torch.no_grad():
        for seq_idx, batch in enumerate(test_loader):
            # Skip empty batches (sequences with no valid pairs)
            if len(batch) == 0:
                print(f"[WARNING] Sequence {seq_idx+1} has no valid frame pairs - skipping")
                continue
                
            print(f"\n=== Sequence {seq_idx+1} ===")
            processed_sequences += 1
            
            for frame_idx, (inp, target) in enumerate(batch):
                try:
                    # Validate input data
                    if inp.x is None or inp.x.shape[0] == 0:
                        print(f"[WARNING] Empty input graph at frame {frame_idx+1} - skipping")
                        continue
                        
                    if target.x is None or target.x.shape[0] == 0:
                        print(f"[WARNING] Empty target graph at frame {frame_idx+1} - skipping")
                        continue
                    
                    # Ensure edge_index is on correct device and type
                    x_in = inp.x.unsqueeze(0).unsqueeze(0).to(device)
                    edge_index = inp.edge_index.to(device)
                    
                    # Forward pass
                    y_pred = model(x_in, edge_index).squeeze(0).cpu()
                    
                    # Validate prediction
                    if torch.isnan(y_pred).any() or torch.isinf(y_pred).any():
                        print(f"[WARNING] Invalid prediction at frame {frame_idx+1} - contains NaN/Inf")
                        continue
                    
                    metrics = compute_metrics(y_pred, target, inp)
                    
                    print(f"Frame {frame_idx+1}: "
                          f"People={metrics['num_people']}, "
                          f"AvgMove={metrics['avg_movement']:.3f}, "
                          f"Anomaly={metrics['anomaly_score']:.3f}")
                    
                    processed_frames += 1
                    
                except Exception as e:
                    print(f"[ERROR] Failed to process frame {frame_idx+1}: {str(e)}")
                    continue
            
            # Just run on one valid sequence for now
            if processed_sequences >= 1:
                break
    
    if processed_sequences == 0:
        print("[ERROR] No sequences could be processed!")
    else:
        print(f"[INFO] Successfully processed {processed_sequences} sequences and {processed_frames} frames")

if __name__ == "__main__":
    main()
